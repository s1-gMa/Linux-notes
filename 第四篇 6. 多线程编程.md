---
tags:
  - 线程
---
## 6.1 线程和进程的区别

- 进程:
  - 操作系统进行资源分配和管理的基本单位
  - 拥有独立的地址空间和资源
- 线程:
  - CPU 调度的基本单位
  - 共享同一进程的地址空间和大部分资源
  - 一个进程可以包含多个线程

## 6.2 线程标识 pthread_t 与 pthread_self

线程标识类型:

    pthread_t

特点:

- 不透明类型(opaque type),内部结构由实现决定.

获取当前线程 ID:

    pthread_t pthread_self(void);

## 6.3 线程的创建 #pthread_API

函数原型:

    int pthread_create(pthread_t *thread,
                       const pthread_attr_t *attr,
                       void *(*start_routine) (void *),
                       void *arg);

参数说明:

- `thread`:用于返回新建线程的线程号
- `attr`:线程属性,常用默认值 `NULL`
- `start_routine`:线程执行的函数
- `arg`:传给线程函数的参数指针

## 6.4 向线程中传入参数 #pthread_API

通常会将多个参数封装到一个结构体中,然后传入:

    struct thread_args {
        int x;
        int y;
    };

    void *thread_func(void *arg) {
        struct thread_args *p = (struct thread_args *)arg;
        /* 使用 p->x, p->y */
        return NULL;
    }

## 6.5 线程的退出和回收 #pthread_API

主动退出当前线程:

    void pthread_exit(void *retval);

取消(请求结束)另一个线程:

    int pthread_cancel(pthread_t thread);

等待指定线程结束并回收资源(阻塞):

    int pthread_join(pthread_t thread, void **retval);

非阻塞等待(实现相关):

    int pthread_tryjoin_np(pthread_t thread, void **retval);

## 6.6 多线程临界资源访问与问题引出(互斥)  #pthread_API

多线程共享同一变量时,如果不加控制,可能出现竞态条件.例如:

- 线程 A 对某个变量不断自增
- 线程 B 对同一个变量不断自减

由于同时访问,最终结果可能与预期不符.为保证临界区操作的正确性,需要使用互斥锁进行保护.

## 6.7 互斥锁 API  #pthread_API

初始化互斥量:

    pthread_mutex_t mutex;
    pthread_mutex_init(&mutex, NULL);

或静态初始化:

    pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;

加锁 / 尝试加锁 / 解锁 / 销毁:

    pthread_mutex_lock(&mutex);       # 阻塞加锁
    pthread_mutex_trylock(&mutex);    # 非阻塞加锁
    pthread_mutex_unlock(&mutex);     # 解锁
    pthread_mutex_destroy(&mutex);    # 销毁

## 6.8 多线程执行顺序控制(信号量引入) 

线程的实际执行顺序具有随机性.如果希望:

- 某些线程先执行
- 限制同时访问共享资源的线程数量

可以引入信号量进行控制.

## 6.9 信号量 API  #sem_API

**信号量作用:解决线程执行顺序**

初始化信号量:

    sem_t sem;
    sem_init(&sem, 0, 初始值);

说明:

- 第二个参数为 0:表示用于线程间同步
- 非 0:表示用于进程间同步

P / V 操作(等待 / 释放):

    sem_wait(&sem);      # P 操作,有资源则 sem-1,无资源则阻塞
    sem_post(&sem);      # V 操作,释放资源,sem+1

非阻塞等待:

    sem_trywait(&sem);   # 若无资源,立即返回错误,而不是阻塞

销毁信号量:

    sem_destroy(&sem);
## 6.10 条件变量

## 6.11 总结

**线程使用流程**

![[4 6.11 线程使用流程.png]]

**互斥量使用流程**

![[4 6.11 互斥量使用流程.png]]

**信号量使用流程**

![[4 6.11 信号量使用流程.png]]
