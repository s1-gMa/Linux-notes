# **1. 交叉编译与 GCC 编译流程**

## 1.1 交叉编译 hello.c

交叉编译命令示例:
	gcc 待编译文件.c -o 生成的可执行文件
	![[4 1.1交叉编译示例.png]]

## 1.2 GCC 编译过程

文件从源码到可执行文件,一般经过四个阶段:

- **预处理**(*preprocessing*)
- **编译**(*compilation*)
- **汇编**(*assembly*)
- **链接**(*linking*)
- ![[4 1.2gcc编译过程.png]]

可以使用 `-v` 选项**显示详细编译信息**,便于排查问题,例如:

- 找不到头文件
- 找不到库文件
- 链接失败等

## 1.3 GCC 总体选项与分步编译的原因

可以把四个步骤拆开进行编译,原因主要有:

- 一次性编译很多源文件时,如果只改动了其中一个文件,却让其他文件也重新编译,会浪费时间
- 通过分步编译,只需重新编译修改过的文件,再进行链接,效率更高

## 1.4 链接库文件(自制静态库与动态库)

需要掌握如何制作并链接静态库(.a)和动态库(.so):

- 静态库在链接阶段被复制到可执行文件中,生成的可执行文件体积较大,但运行时不再依赖外部库文件
- 动态库在程序运行时由系统加载,可以被多个程序共享,节省内存与磁盘空间

---

# **2. Makefile 基础**

## 2.1 规则

规则是 Makefile 的基本元素,格式为:

    目标(target)... : 依赖(prerequisites)...
        命令(command)

**注**:make 会比较文件时间(例如 `a.c` 与 `a.o`,`test` 与 `a.o`) 判断是否需要重新生成目标:

- 依赖文件比目标文件新
- 目标文件不存在

示例:

    test : a.o b.o
        gcc -o test a.o b.o

    a.o : a.c
        gcc -c -o a.o a.c

    b.o : b.c
        gcc -c -o b.o b.c

## 2.2 常用函数
### 2.2.1foreach

语法:

    $(foreach var, list, text)

含义:*for each var in list, change it to text*
	对 `list` 中的每个元素依次赋给 `var`,再把 `var` 替换到 `text` 中.

示例:

    objs := a.o b.o
    dep_files := $(foreach f, $(objs), .$(f).d)

结果:

	 dep_files  = .a.o.d .b.o.d

### 2.2.2wildcard

语法:

    $(wildcard pattern)

含义:列出匹配 `pattern` 的所有存在文件.

示例:

    src_files := $(wildcard *.c)

结果:

- src_files 中保存当前目录下所有 `.c` 文件的文件名.

## 2.3 语法与通配符

常用通配符和自动变量:

- `%.c` / `%.o`:匹配相同前缀的 `.c` / `.o` 文件
- `$@`:当前规则的目标文件名
- `$<`:第一个依赖文件名
- `$^`:所有依赖文件名

简化前面的示例:

    test : a.o b.o c.o
        gcc -o test $^

    %.o : %.c
        gcc -c -o $@ $<

## 2.4 假想目标 

可以通过 `.PHONY` 声明伪目标,避免和同名文件冲突:

    .PHONY: clean

- 如果当前目录下有一个名为 `clean` 的文件,执行 `make clean` 时,make 会认为目标已经是最新的,不去执行规则.
- 将其声明为 `.PHONY` 后,无论有没有同名文件,命令都会执行.

常见伪目标:`clean`,`all`,`install` 等.

## 2.5 变量:延时变量与即时变量(=,:=,+=)

示例:

    A = xxx      # 延时变量(递归展开)
    B = yyy      # 延时变量
    C := zzz     # 即时变量(简单展开,定义时就展开)
    D += uuu     # 追加赋值(类型取决于第一次定义)

区别:

- 延时变量:在"使用时"才展开,可以引用其它尚未定义完全的变量.
- 即时变量:在"定义时"就展开,类似 C 语言中的宏展开.

## 2.6 自动检测头文件是否更改(依赖文件 .*.d)

典型结构:

    objs := main.o sub.o

    test : $(objs)
        gcc -o test $^

    dep_files := $(foreach f, $(objs), .$(f).d)
    dep_files := $(wildcard $(dep_files))

    ifneq ($(dep_files),)
    include $(dep_files)
    endif

    %.o : %.c
        gcc -Wp,-MD,.$@.d -c -o $@ $<

    clean:
        rm *.o test -f

    distclean:
        rm $(dep_files) *.o test -f

说明:

- 在编译 `.c` 文件时使用 `-Wp,-MD,.$@.d`,生成依赖文件 `.<目标>.d`.
- 通过 `include` 把这些依赖文件包含进来,就能在头文件变化时自动重新编译相关的 `.o` 文件.

## 2.7 CFLAGS:编译选项与头文件目录

常见用法:

- 1.开启额外的编译检查(例如把 warning 当作 error):

    `CFLAGS += -Werror`

- 2.指定额外的头文件搜索路径:

    `CFLAGS += -Iinclude`

---

# **3. 文件 IO**

## 3.1 文件 IO 函数分类

使用**POSIX**接口 从而可以在不同版本的Linux Unix发行版运行

常见分类:

- 1.**标准 IO**:
  - `fopen`,`fread`,`fwrite`,`fseek`,`fflush`,`fclose` 等
  - 使用用户态缓冲区,提高读写效率
- 2.**系统调用 IO**:
  - `open`,`read`,`write`,`lseek`,`fsync`,`close` 等
  - 直接与内核交互,不做用户态缓冲

关系:

- 标准 IO 是在系统调用 IO 的基础上再封装一层用户缓冲区(),以减少频繁陷入内核的次数,从而提高效率.
- (只有第一次进入内核 后面在用户buffer中操作 如果用户buffer满了 调用系统IO写入硬件)
- ![[4 3.1标准IO和系统IO关系.png]]


## 3.2 系统调用接口

典型接口原型(仅作记忆用,可用 `man` 查详细):

    int open(const char *pathname, int flags, ...);
    ssize_t read(int fd, void *buf, size_t count);
    ssize_t write(int fd, const void *buf, size_t count);
    off_t lseek(int fd, off_t offset, int whence);
    int fsync(int fd);
    int close(int fd);

## 3.3 标准 IO 接口

常见函数原型:

    FILE *fopen(const char *pathname, const char *mode);
    size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream);
    size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream);
    int fseek(FILE *stream, long offset, int whence);
    int fflush(FILE *stream);
    int fclose(FILE *stream);

## 3.4 内部机制与用户缓冲区

缓冲模式大致包括:

- 全缓冲
- 行缓冲
- 无缓冲

注意:

- 调用 `fwrite` 写入的数据,通常先进入用户态缓冲区,可能不会立刻写入磁盘.
- 为保证数据及时写入,可以调用 `fflush` 或 `fclose`.

---

# **4. Framebuffer 应用编程**

## 4.1 LCD 操作原理(像素坐标与 BPP)

在 LCD 上设置某个像素 `(x, y)` 的颜色,一般步骤:

1. 打开 framebuffer 设备(如 `/dev/fb0`).
2. 使用 `ioctl` 获取屏幕信息(分辨率,BPP 等).
3. 使用 `mmap` 将显存映射到用户空间.
4. 根据 `(x, y)` 坐标和 BPP(*bits per pixel*,每个像素占多少位)计算该像素在显存中的偏移地址.
5. 向该偏移处写入对应颜色值.(**用地址访问硬件的时候要在基地址上加偏移地址**) 

![[4 4.1LCD操作原理.png]]

---

# **5. 输入系统应用编程**

## 5.1 输入系统框架

用户态通过 `/dev/input/eventX` 读取输入事件,内核中由各个输入设备驱动上报事件,经 input 子系统统一管理与分发.

![[4 5.1输入系统框架.png]]

## 5.2 APP 获取的输入事件结构体(type / code / value)

用户程序从 `/dev/input/eventX` 中读取到的输入数据,一般是一个 `input_event` 结构体,主要字段包括:

- `type`:事件类型
  - 例如:按键类,相对位移类,绝对坐标类等
- `code`:子类具体编码
  - 例如:`REL_X`,`REL_Y`,`ABS_X`,某个具体按键编码等
- `value`:事件值
  - 对按键来说:1 表示按下,0 表示松开
  - 对位移/坐标来说:表示偏移值或位置
  - 对压力来说:表示压力大小
![[4 5.2输入数据结构体.png]]

完整的一次输入操作往往由多条事件组成.发送完一组事件后,内核会再上报一个同步事件(如 `SYN_REPORT` 图示为发送一串`0000`),告诉用户程序"这一组事件结束了,下一条开始是下一组数据".

示意图占位:

![[4 5.2触摸屏的输入事件数据.png]]

## 5.3 调试技巧

常用调试命令:
	`ls /dev/input/* -l` **查看有哪些设备节点**
	`cat /proc/bus/input/devices` **查看不同设备节点分别对应什么硬件**
![[4 5.3调试查看设备.png]]
可以配合 `hexdump`,`od`,`evtest` 等工具观察事件数据.

## 5.4 输入系统相关 API

用户态常用 API:

- `open()` 打开 `/dev/input/eventX`
- `read()` 循环读取 `input_event` 结构体
- `ioctl()` 查询或设置某些设备属性

---

# **6. 多线程编程**

## 6.1 线程和进程的区别

- 进程:
  - 操作系统进行资源分配和管理的基本单位
  - 拥有独立的地址空间和资源
- 线程:
  - CPU 调度的基本单位
  - 共享同一进程的地址空间和大部分资源
  - 一个进程可以包含多个线程

## 6.2 线程标识 pthread_t 与 pthread_self

线程标识类型:

    pthread_t

特点:

- 不透明类型(opaque type),内部结构由实现决定.

获取当前线程 ID:

    pthread_t pthread_self(void);

## 6.3 线程的创建

函数原型:

    int pthread_create(pthread_t *thread,
                       const pthread_attr_t *attr,
                       void *(*start_routine) (void *),
                       void *arg);

参数说明:

- `thread`:用于返回新建线程的线程号
- `attr`:线程属性,常用默认值 `NULL`
- `start_routine`:线程执行的函数
- `arg`:传给线程函数的参数指针

## 6.4 向线程中传入参数

通常会将多个参数封装到一个结构体中,然后传入:

    struct thread_args {
        int x;
        int y;
    };

    void *thread_func(void *arg) {
        struct thread_args *p = (struct thread_args *)arg;
        /* 使用 p->x, p->y */
        return NULL;
    }

## 6.5 线程的退出和回收

主动退出当前线程:

    void pthread_exit(void *retval);

取消(请求结束)另一个线程:

    int pthread_cancel(pthread_t thread);

等待指定线程结束并回收资源(阻塞):

    int pthread_join(pthread_t thread, void **retval);

非阻塞等待(实现相关):

    int pthread_tryjoin_np(pthread_t thread, void **retval);

## 6.6 多线程临界资源访问与问题引出(互斥)

多线程共享同一变量时,如果不加控制,可能出现竞态条件.例如:

- 线程 A 对某个变量不断自增
- 线程 B 对同一个变量不断自减

由于同时访问,最终结果可能与预期不符.为保证临界区操作的正确性,需要使用互斥锁进行保护.

## 6.7 互斥锁 API

初始化互斥量:

    pthread_mutex_t mutex;
    pthread_mutex_init(&mutex, NULL);

或静态初始化:

    pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;

加锁 / 尝试加锁 / 解锁 / 销毁:

    pthread_mutex_lock(&mutex);       # 阻塞加锁
    pthread_mutex_trylock(&mutex);    # 非阻塞加锁
    pthread_mutex_unlock(&mutex);     # 解锁
    pthread_mutex_destroy(&mutex);    # 销毁

## 6.8 多线程执行顺序控制(信号量引入)

线程的实际执行顺序具有随机性.如果希望:

- 某些线程先执行
- 限制同时访问共享资源的线程数量

可以引入信号量进行控制.

## 6.9 信号量 API

初始化信号量:

    sem_t sem;
    sem_init(&sem, 0, 初始值);

说明:

- 第二个参数为 0:表示用于线程间同步
- 非 0:表示用于进程间同步

P / V 操作(等待 / 释放):

    sem_wait(&sem);      # P 操作,有资源则 sem-1,无资源则阻塞
    sem_post(&sem);      # V 操作,释放资源,sem+1

非阻塞等待:

    sem_trywait(&sem);   # 若无资源,立即返回错误,而不是阻塞

销毁信号量:

    sem_destroy(&sem);
