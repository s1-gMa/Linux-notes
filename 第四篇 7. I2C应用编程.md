---
tags:
  - 通信协议
  - I2C
---
## 7.1 I2C硬件框架 

- SCL & SDA
- 两条线上都有上拉电阻
## 7.2 I2C软件框架

**APP -> I2C驱动 -> I2C控制器**

- APP: 提供调用接口 不关心底层实现
- IC2驱动: 构造数据发送给I2C地址和数据 # 驱动知道地址 数据格式 发送是否成功
- I2C控制器: 根据协议发送数据并判断

**对于Linux**

- APP 内核驱动 控制器三层相互合作去访问设备
```text
  【APP 用户态】
  ├─ 方式 A：针对具体 I2C 设备的用户接口（/dev/xxx, /sys/..., input 等）
  │        ↓
  │   I2C 设备驱动（内核态 client driver）
  │        ↓
  └─ 方式 B：/dev/i2c-X（通用 I2C 总线接口）
           ↓
     i2c-dev.c（内核态，通用 I2C 字符设备驱动）
           ↓
     I2C 核心 + I2C 控制器驱动（adapter）
           ├─ 硬件 I2C 控制器驱动
           └─ GPIO 模拟 I2C（i2c-gpio.c）
           ↓
        SCL / SDA 物理线
  ```

**I2C读写的数据格式**

![[4 7.2I2C写.png]]

![[4 7.2I2C读.png]]

## 7.3 SMBus协议

- 是I2C协议的一个子集 SMBus: ***System Management Bus*** 系统管理总线
- **系统和电源管理等任务的控制总线**
- 和I2C的区别

## 7.4 I2C的重要结构体 #I2C 

**参考资料:**
- linux驱动:/driver/i2c
- I2CTools:[Index of /pub/software/utils/i2c-tools/](https://mirrors.edge.kernel.org/pub/software/utils/i2c-tools/)
- [[嵌入式] i2c-tools 工具安装使用教程-CSDN博客](https://blog.csdn.net/m0_37383484/article/details/140105662)

### 7.4.1结构体 (见[[I2C结构体原型及注释]]) #I2C 

**[Linux系统驱动之I2C_Adapter驱动框架讲解与编写CSDN博客](https://blog.csdn.net/thisway_diy/article/details/119906746)**
- **i2c_adapter**
- **i2c_algorithm**
- **i2c_client**
- **i2c_driver**
- **i2c_board_info**

**过程:**
- **总线类型**
    
    - I2C 总线类型由内核提供（`i2c_bus_type`），适配器（`i2c_adapter`）和设备驱动（`i2c_driver`）都注册到这个 bus_type 上。
        
- **适配器 & 算法**
    
    - I2C 控制器驱动创建并注册 `i2c_adapter`，在其中填好 `algo`（`struct i2c_algorithm`），负责“怎么真正发 I2C/SCL/SDA”。
        
- **板级描述 I2C 设备**
    
    - 通过 Device Tree / ACPI / `i2c_board_info` 等方式描述“哪条总线上挂了哪些从设备”，由内核创建对应的 `i2c_client`。
        
- **设备驱动定义 `i2c_driver`**
    
    - 编写 `struct i2c_driver`，实现 `probe/remove/shutdown/alert/...` 等回调，注册到 I2C 核心。
        
- **匹配 & 回调 `probe()`**
    
    - I2C 核心在 bus 上匹配 `i2c_client` 与 `i2c_driver`；
        
    - 一旦匹配成功，就调用 `driver->probe(client, ...)`，在其中完成从设备初始化。
        
- **实际访问设备**
    
    - 在 `probe()` 或后续的读写函数中：
        
        - 可以用 `i2c_smbus_*`（内部使用 SMBus/I2C）；
            
        - 或构造 `struct i2c_msg` 数组，调用 `i2c_transfer()`；
            
    - 这些 API 最终会通过 `client->adapter->algo->master_xfer()` 等函数，调用到底层适配器驱动，真正驱动硬件拉动 SCL/SDA。

===**核心思想:内核会在总线中将定义的驱动和从机匹配 如果匹配上了就调用驱动**===

