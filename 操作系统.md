# 第一章 操作系统引论
## 1.1操作系统的目标和作用
**定义:**
- 管理和控制计算机系统软硬件资源 方便用户使用计算机的系统软件

**目标:**
- 方便性 有效性 可扩充性 开放性

**作用:**
- 用户和硬件的接口
- 管理资源
- 资源接口
## 1.2 操作系统的发展过程
**过程:**
- 批处理系统(单道批处理->多道批处理)->分时系统->实时系统
- 批处理 分时 实时是**三种基本**操作系统
## 1.3 操作系统的基本特征
**1.并发**
- 并发:多个事件在同一时间间隔内发生(微观上依次进行) ^ff72d9
- 并行:多个事件在同一时刻发生

**2.共享**
- 在操作系统的协调下 多个程序共用系统中的软硬件资源
- 支持同时访问&互斥共享

**3.虚拟**

**4.异步**:
- 进程以不可预知的方式推进 即停停走走
## 1.3 操作系统的主要功能
- 处理机管理    存储器管理    设备管理    文件管理

# 第二章 进程的描述与控制
## 2.1前趋图和程序执行
程序顺序执行    程序并发执行
## 2.2 进程的描述
1.进程的定义:**系统调用的最小单位** 由一组机器指令 数据 堆栈组成
2.进程的基本状态:**就绪 运行 阻塞**(创建和终止)
![[复习-操作系统-2.2-进程三种基本状态转换.png]]
3.**PCB内容:标识 现场信息 资源信息 控制信息** ^2764c8
## 2.3 进程控制
1.操作系统内核分为**系统态和用户态**
2.**原语**:创建 终止 阻塞 唤醒 挂起 激活
## 2.4 进程同步
1.**同步与互斥**    临界资源    临界区

**2.四个约束条件:**
- **空闲让进**
- **忙则等待**
- **优先等待**
- **让权等待**

**3.信号量:**
- **互斥信号量 计数信号量**
- PV操作

## 2.5 进程同步问题
**PV 上锁解锁操作必须成对出现**
**1.生产者-消费者问题:**
- 生产者生产数据放入缓冲区 消费者从缓冲区中取出数据
```C
var items = 0, space = 10, mutex = 1;
var in = 0, out = 0;
item buf[10] = { NULL };

producer {
    while( true ) {
        wait( space );  // 等待缓冲区有空闲位置， 在使用PV操作时，条件变量需要在互斥锁之前
        wait( mutex );  // 保证在product时不会有其他线程访问缓冲区

        // product
        buf.push( item, in );  // 将新资源放到buf[in]位置 
        in = ( in + 1 ) % 10;
        
        signal( mutex );  // 唤醒的顺序可以不同
        signal( items );  // 通知consumer缓冲区有资源可以取走
    }
}

consumer {
    while( true ) {
        wait( items );  // 等待缓冲区有资源可以使用
        wait( mutex );  // 保证在consume时不会有其他线程访问缓冲区

        // consume
        buf.pop( out );  // 将buf[out]位置的的资源取走
        out = ( out + 1 ) % 10;

        signal( mutex );  // 唤醒的顺序可以不同
        signal( space );  // 通知缓冲区有空闲位置
    }
}
```

**2.哲学家进餐问题**:
- 哲学家得到两根筷子开始进餐 进餐结束开始思考
![[复习-操作系统-2.5-哲学家进餐问题.png]]

```C
semaphore chopstick[5] = {1,1,1,1,1}; //定义信号量数组chopstick[5],并初始化
Pi(){  //i号哲学家的进程
    while(1){
        P(chopstick[i]); //取左边筷子
        P(chopstick[(i+1)%5]);  //取右边篌子
        eat;  
        V(chopstick[i]); //放回左边筷子
        V(chopstick[(i+1)%5]);  //放回右边筷子
        think;  
    } 
}
```
- 可能产生死锁的原因: 五个哲学家同时拿起左边的筷子
- **死锁解决方法:**
	- 只允许同时四个哲学家拿筷子
	- 只有哲学家的左右筷子都可用 才允许他拿筷子进餐
	- 规定奇数哲学家先拿左边筷子 再拿右边 规定右边哲学家先拿右边筷子 再拿左边

**3.读者-写者问题:**
- 允许多个进程同时读 在写的过程中不能有其他进程进行读写
```C
semaphore rmutex=1，wmutex=1；
int readcount=0；
void reader(){//读者
	do{
		wait(rmutex)；//申请对readcount的使用
		if(readcount==0)wait(wmutex);//第一个读者阻止后面的写者使用
		readcount++;
		signal(rmutex);//释放对readcount的使用
	
		read;//读者读

		wait(rmutex);//申请对readcount的使用
		readcount--;
		if(readcount==0)signal(wmutex);//最后一个读者使用完，写者才可使用
		signal(rmutex);//释放对readcount的使用
	}while(TRUE);
}

void writer(){//写者
	do{
		wait(wmutex);//申请读文件
		write;//写者写
		signal(wmutex);//释放文件资源
	}while(TRUE);
}
```
- **详解:**
	- wmutex的含义是当前文件的使用权 不是写操作 
	- rmutex的含义是保护readcount变量
	- 在reader()函数中wait()和signal()中间的代码部分是互斥信号量(rmutex)的互斥区 作用是保护readcount

## 2.6 进程通信
- [[面试#^7a74bd]]
## 2.7&2.8 线程
- [[第四篇 6. 多线程编程]]

# 第三章 处理机调度与死锁
## 3.1处理机调度的层次和调度算法的目标
**1.层次:**
- **作业调度**
- **进程调度**
- **内存调度**

**2.目标**: CPU 利用率 吞吐量 周转时间 响应时间 公平性等
## 3.2 作业与作业调度
1.定义: 
- 用户在一次运行过程中 为完成某个特定任务而提交给系统的**程序 数据和相关说明的集合** 含有作业控制块(JCB)

2.调度算法
- **先来先服务(first-come first-served FCFS)**
- **短作业优先(short job first SJF)**
- **高相应比优先(Highest Response Ratio Next HRRN)**

## 3.3 进程调度
1.调度方式:
- 非抢占
- 抢占

## 3.4 实时调度

## 3.5 死锁
1.定义:一组进程中每个进程都在等待该组中其他进程才能引发的事件
2.产生死锁的**必要条件**:
- 互斥
- 请求和保持
- 不可抢占
- 循环等待

**3.处理死锁**的方法:
- **预防:**
	- 破坏死锁产生的后三个条件
- **避免:**
	- 系统处于安全状态
	- 银行家算法
- **检测**
- **解除**

**银行家算法:**

# 第四章 存储器管理
## 4.1 存储器的层次结构
![[复习-操作系统-4.1-计算机系统存储层次示意图.png]]

## 4.2 程序的装入和链接
1.程序可执行的步骤:
- **编译 链接 装入**

**2.链接:**
- 把编译得到的目标模块(.o)和所需的库函数装配成一个完整的装入模块
- 静态链接:
	- 在程序运行之前 把各目标模块和所需的库函数收集起来 通过**修改相对地址 + 变换外部调用符号**连接成一个完整的装配模块
- 动态链接:
	- 在装入和运行时 将程序所需的部分代码做成独立的共享模块

**3.装入:**
- 把装入模块装入内存
- 地址重定位: OS把逻辑地址转为物理地址
- 静态重定位:
	- 装入时计算绝对地址 = 装入起始地址 + 逻辑地址
- 动态重定位:
	- 程序访问内存时计算物理地址 = 重定位寄存器(基址) + 逻辑地址

# 第九章 操作系统接口
**1.系统调用与一般过程调用的区别**
- **系统调用是用户进程进入内核 请求操作系统服务的一种受控入口**
- **一般过程调用只是同一特权级内部的普通函数调用**

|              | 一般过程调用                   | 系统调用                                                         |
| ------------ | ------------------------ | ------------------------------------------------------------ |
| **运行级别**     | 在**同一特权级**下运行(都在用户态/内核态) | 调用者在**用户态** 被调用的服务在内核态<br>会发生一次**用户态->内核态**的特权级切换<br>        |
| **进入方式**     | 通过call指令/函数调用指令          | 通过**专门的陷入指令**(软中断 syscall等)<br>本质是一次**软中断/陷入** 由硬件转入内核       |
| **执行的代码/功能** | 执行用户函数 只能操作本进程的私有资源      | 执行的是**内核中的系统调用程序服务**<br>完成硬件和系统资源相关的操作(进程创建 文件读写 设备IO 内存管理等) |
| **安全性与检查**   | 不涉及特权检查                  | 内核会进行参数检查 权限检查 防止用户程序非法使用资源或破坏系统                             |
| **开销**       | 用户态内部栈操作+PC跳转 开销小        | 需要用户态/内核态切换 保存/恢复现场 有一定**上下文切换开销**                           |

**2.系统调用过程**
1. 用户程序发出系统调用请求
2. CPU由用户态切换到内核态
3. 内核中执行相应的系统调用服务程序
4. 返回用户态继续执行用户程序





# 大纲

## 第一章 操作系统引论

1. 理解操作系统的目标  
2. 理解 OS 的作用  
3. 理解操作系统的功能  
4. 理解多道、并发 OS 的含义  
5. 掌握多道批处理 OS、分时 OS、实时 OS 的基本特性；掌握分时 OS 的基本特点和响应时间概念及公式  
   - T = n × q  
6. 了解 OS 设计目的  
7. 理解 OS 的基本特性及含义：并发性、共享性、虚拟性、异步性  
8. 理解 OS 的五大基本功能  
9. 理解内核概念，知道什么是微内核和强内核  
10. 了解 OS 结构设计（模块、分层、微内核的基本概念）  
11. 理解内核态、用户态概念  
12. 理解系统调用概念、功能、过程，并能理解系统调用和普通函数的区别，能够结合具体系统调用和函数理解二者的区别  
13. 理解中断、异常概念  

---

## 第二章 进程的描述与控制

### 一、进程概念及控制

1. 理解进程概念  
2. 理解进程及其执行的四大特征及含义  
3. 理解 PCB 概念，了解 PCB 存储的基本信息；知道一个进程对应一个 PCB，PCB 是进程的唯一标志，伴随进程的整个生命周期  
4. 理解进程和程序的区别  
5. 理解进程的基本特征  
6. 理解进程三态与五态基本状态及转换关系和时机  
7. 理解进程控制块的组织形式  
8. 理解原语概念。理解 OS 是对系统硬件的第一次延伸，通过执行各种原语操作来实现对进程的控制（创建、调度、通信、撤销等）。了解下列原语：  
   - （1）进程创建原语：`create()`  
   - （2）进程撤销原语：`destroy()`  
   - （3）阻塞原语、唤醒原语：`block()`、`wakeup()`  
   - （4）挂起原语、激活（解挂）原语：`suspend()`、`active()`  
9. 理解进程创建、撤销、唤醒、阻塞的基本过程和时机  
10. 理解进程上下文切换  

### 二、进程同步与互斥

1. 理解进程之间的两种相互制约关系  
2. 理解临界资源、临界区、信号量、记录型信号量（重点）等概念  
3. 理解经典同步问题：  
   - 生产者–消费者问题（包含单缓冲区和多缓冲区问题）  
   - 读者–写者问题  
   - 哲学家就餐问题  
   - 分苹果问题等  
4. 理解进程通信概念，理解消息通信和低级通信概念；了解高级通信的基本形式和基本含义；理解消息队列机制  
5. 理解线程概念和特性  

---

## 第三章 进程调度和死锁

1. 理解进程调度概念  
2. 理解单级调度与中级、低级调度  
3. 理解进程调度策略（FCFS、SJF、优先权、高响应比、时间片轮转、多级反馈队列〔了解基本含义〕）的含义和特点  
4. 死锁  
   5. 产生死锁的原因  
   6. 产生死锁的 4 个必要条件  
   7. 处理死锁的基本方法  
   8. 死锁的预防（具体条件）  
   9. 死锁的避免（银行家算法）  
   10. 了解系统模型  
   11. 死锁的检测与解除（基本思路）  

---

## 第四章 + 第五章 内存管理

1. 理解虚拟存储器概念和特征  
2. 理解地址重定位、静态重定位、动态重定位  
3. 理解静态链接的原理，了解动态链接的基本含义  
4. 理解早期动态分区内存管理思想；理解内存分配策略（FF、BF、WF 算法策略）和内存回收策略  
5. 理解内存管理中 cache 的作用  
6. 理解请求分页管理原理，缺页中断处理过程  
7. 理解请求分段管理原理  
8. 理解请求段页式内存管理原理  
9. 理解页面置换算法（FIFO、OPT、LRU、CLOCK/NRU）  
10. 理解抖动现象  
11. 理解程序局部性原理  
12. 理解二级页表  

---

## 第六章 设备管理

1. 了解设备分类  
2. 了解设备管理的功能和基本组成  
3. 掌握三种 I/O 控制方式的基本原理和特征，重点掌握中断和 DMA 控制方式  
4. 理解 I/O 相关的软件：  
   - 设备无关软件  
   - 设备驱动程序  
   - 中断处理程序  
   - 用户层 I/O 软件（即系统调用）  
5. 理解 I/O 管理的作用、功能及分配算法  
6. 理解 I/O 软件层次，参考下图理解每层功能和层间关系  

> **此处插入 I/O 请求 / I/O 应答 层次结构图**

7. 掌握 Spooling 技术（基本原理和组成）以及如何应用  
8. 掌握磁盘访问时间、磁盘调度算法  

---

## 第七章 文件管理

1. 了解文件系统逻辑组织  
2. 理解 FCB 概念（FCB 即目录中的一项）  
3. 理解索引结点 Inode 概念  
4. 理解文件目录管理（重点：树型目录）  

---

## 第八章 磁盘存储器的管理

1. 理解文件存储的组织方式（基本原理、优缺点、适用场合）  
2. 理解文件存储空间管理（空闲表、空闲链表、位示图）  
3. 了解提高磁盘 I/O 速度的措施  
4. 了解文件的共享方式（硬链接和软链接）  
5. 了解提高磁盘可靠性的技术及基本原理  
6. 了解如何保证数据安全、可靠、一致性的一些技术及基本原理  

---

## 第九章 接口

1. 系统调用与一般过程调用的区别  
2. 系统调用过程  

---

## 算法重点

1. 进程调度算法：FCFS、SJF（含优先权与高响应比）、时间片轮转  
   - 能计算各进程周转时间和平均周转时间  
2. 进程同步：  
   - `wait(s)`、`signal(s)` 公式  
   - 多进程并发执行时 `wait(s)`、`signal(s)` 操作下数据的变化  
   - 生产者–消费者（单/多缓冲区）、读者–写者、哲学家就餐等问题  
3. 死锁中的银行家算法  
4. 存储管理中：  
   - 动态分区管理 FF、BF、WF 算法  
   - 请求分页、请求分段方式中虚拟地址到逻辑地址映射的计算  
5. 逻辑地址到物理地址变换  
6. 分页、分段、段页式存储管理的地址变换过程  
7. 页面置换算法（FIFO、OPT、LRU、CLOCK/NRU）  
8. 磁盘调度算法（FIFO、SSTF、SCAN、CSCAN）  


