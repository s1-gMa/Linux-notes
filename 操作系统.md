# 第一章 操作系统引论
## 1.1操作系统的目标和作用
**定义:**
- 管理和控制计算机系统软硬件资源 方便用户使用计算机的系统软件
**目标:**
- 方便性 有效性 可扩充性 开放性
**作用:**
- 用户和硬件的接口
- 管理资源
- 资源接口
## 1.2 操作系统的发展过程
**过程:**
- 批处理系统(单道批处理->多道批处理)->分时系统->实时系统
- 批处理 分时 实时是**三种基本**操作系统
## 1.3 操作系统的基本特征
**1.并发**
- 并发:多个事件在同一时间间隔内发生(微观上依次进行) ^ff72d9
- 并行:多个事件在同一时刻发生
**2.共享**
- 在操作系统的协调下 多个程序共用系统中的软硬件资源
- 支持同时访问&互斥共享
**3.虚拟**
**4.异步**:进程以不可预知的方式推进 即停停走走
## 1.3 操作系统的主要功能
- 处理机管理    存储器管理    设备管理    文件管理

# 第二章 进程的描述与控制
## 2.1前趋图和程序执行
程序顺序执行    程序并发执行
## 2.2 进程的描述
1.进程的定义:**系统调用的最小单位** 由一组机器指令 数据 堆栈组成
2.进程的基本状态:**就绪 运行 阻塞**(创建和终止)
![[复习-操作系统-2.2-进程三种基本状态转换.png]]
3.**PCB内容:标识 现场信息 资源信息 控制信息** ^2764c8
## 2.3 进程控制
1.操作系统内核分为**系统态和用户态**
2.**原语**:创建 终止 阻塞 唤醒 挂起 激活
## 2.4 进程同步
1.**同步与互斥**    临界资源    临界区

2.四个约束条件:
- **空闲让进**
- **忙则等待**
- **优先等待**
- **让权等待**

3.信号量:
- **互斥信号量 计数信号量**
- PV操作

## 2.5 进程同步问题
**PV 上锁解锁操作必须成对出现**
**1.生产者-消费者问题:**
- 生产者生产数据放入缓冲区 消费者从缓冲区中取出数据
```C
var items = 0, space = 10, mutex = 1;
var in = 0, out = 0;
item buf[10] = { NULL };

producer {
    while( true ) {
        wait( space );  // 等待缓冲区有空闲位置， 在使用PV操作时，条件变量需要在互斥锁之前
        wait( mutex );  // 保证在product时不会有其他线程访问缓冲区

        // product
        buf.push( item, in );  // 将新资源放到buf[in]位置 
        in = ( in + 1 ) % 10;
        
        signal( mutex );  // 唤醒的顺序可以不同
        signal( items );  // 通知consumer缓冲区有资源可以取走
    }
}

consumer {
    while( true ) {
        wait( items );  // 等待缓冲区有资源可以使用
        wait( mutex );  // 保证在consume时不会有其他线程访问缓冲区

        // consume
        buf.pop( out );  // 将buf[out]位置的的资源取走
        out = ( out + 1 ) % 10;

        signal( mutex );  // 唤醒的顺序可以不同
        signal( space );  // 通知缓冲区有空闲位置
    }
}
```

**2.哲学家进餐问题**:
- 哲学家得到两根筷子开始进餐 进餐结束开始思考
![[复习-操作系统-2.5-哲学家进餐问题.png]]

```C
semaphore chopstick[5] = {1,1,1,1,1}; //定义信号量数组chopstick[5],并初始化
Pi(){  //i号哲学家的进程
    while(1){
        P(chopstick[i]); //取左边筷子
        P(chopstick[(i+1)%5]);  //取右边篌子
        eat;  
        V(chopstick[i]); //放回左边筷子
        V(chopstick[(i+1)%5]);  //放回右边筷子
        think;  
    } 
}
```
- 可能产生死锁的原因: 五个哲学家同时拿起左边的筷子
- **死锁解决方法:**
	- 只允许同时四个哲学家拿筷子
	- 只有哲学家的左右筷子都可用 才允许他拿筷子进餐
	- 规定奇数哲学家先拿左边筷子 再拿右边 规定右边哲学家先拿右边筷子 再拿左边
**3.读者-写者问题:**
- 允许多个进程同时读 在写的过程中不能有其他进程进行读写
```C
semaphore rmutex=1，wmutex=1；
int readcount=0；
void reader(){//读者
	do{
		wait(rmutex)；//申请对readcount的使用
		if(readcount==0)wait(wmutex);//第一个读者阻止后面的写者使用
		readcount++;
		signal(rmutex);//释放对readcount的使用
	
		read;//读者读

		wait(rmutex);//申请对readcount的使用
		readcount--;
		if(readcount==0)signal(wmutex);//最后一个读者使用完，写者才可使用
		signal(rmutex);//释放对readcount的使用
	}while(TRUE);
}

void writer(){//写者
	do{
		wait(wmutex);//申请读文件
		write;//写者写
		signal(wmutex);//释放文件资源
	}while(TRUE);
}
```
- **详解:**
	- wmutex的含义是当前文件的使用权 不是写操作 
	- rmutex的含义是保护readcount变量
	- 在reader()函数中wait()和signal()中间的代码部分是互斥信号量(rmutex)的互斥区 作用是保护readcount

## 2.6 进程通信
- [[面试#^7a74bd]]
## 2.7&2.8 线程
- [[第四篇 6. 多线程编程]]

# 第三章 处理机调度与死锁
## 3.1处理机调度的层次和调度算法的目标
**1.层次:**
- **作业调度**
- **进程调度**
- **内存调度**
2.目标: CPU 利用率 吞吐量 周转时间 响应时间 公平性等
## 3.2 作业与作业调度
1.定义: 
- 用户在一次运行过程中 为完成某个特定任务而提交给系统的**程序 数据和相关说明的集合** 含有作业控制块(JCB)
2.调度算法
- **先来先服务(first-come first-served FCFS)**
- **短作业优先(short job first SJF)**
- **高相应比优先(Highest Response Ratio Next HRRN)**

## 3.3 进程调度
1.调度方式:
- 非抢占
- 抢占
2.调度算法

## 3.4 实时调度

## 3.5 死锁
1.定义:一组进程中每个进程都在等待该组中其他进程才能引发的事件
2.产生死锁的**必要条件**:
- 互斥
- 请求和保持
- 不可抢占
- 循环等待
3.**处理死锁**的方法:
- **预防:**
	- 破坏死锁产生的后三个条件
- **避免:**
	- 系统处于安全状态
	- 银行家算法
- **检测**
- **解除**

**银行家算法:**

# 第四章 存储器管理
## 4.1 存储器的层次结构

